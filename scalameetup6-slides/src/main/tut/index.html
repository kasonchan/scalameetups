<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <title>Scala Basics Tour II & Functional Programming?</title>
    <style>
        @import url(https://fonts.googleapis.com/css?family=Roboto+Mono);
        @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
        @import url(https://fonts.googleapis.com/css?family=Droid+Sans:400,700,400italic);
        @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
        @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);
        @import url(https://fonts.googleapis.com/css?family=McLaren);

        body {
            font-family: 'McLaren', cursive;
        }

        h1, h2, h3 {
            font-family: 'McLaren', cursive;
            font-weight: normal;
        }

        a {
            color: #65a9b6;
            text-decoration-skip: ink;
            -webkit-text-decoration-skip: ink;
        }

        .remark-code, .remark-inline-code {
            background: #223040 !important;
            font-family: 'Ubuntu Mono';
            font-size: 100%;
        }

        .remark-container {
            background-color: white;
        }

        .remark-slide-content {
            background-color: white;
            color: #2b2b2b;
            font-size: 22px;
        }

        .remark-slide-scaler {
            box-shadow: none;
        }

        .vertical-align-middle * {
            vertical-align: middle;
        }

        @media print {
            .remark-slide-scaler {
                width: 100% !important;
                height: 100% !important;
                transform: scale(1) !important;
                top: 0 !important;
                left: 0 !important;
            }
        }
    </style>
    <script src="https://use.fontawesome.com/3729cac000.js"></script>
</head>
<body>
<textarea id="source">

class: center, middle

## Scala Basics Tour II & <br/> Functional Programming?

### Kason Chan

???

Welcome to today's meetup. Today we will finish up the Scala basics about Scala
collections, we will talk more about traits and then talk about FP and have
a discussion on what is FP?

---

### This talk was compiled with [tut](https://github.com/tpolecat/tut)

```tut:book
val helloWorld = "Hello World!"
println(helloWorld)
```

---

### Agenda

* Collections
* Traits
* Functional Programming in Scala
* Functors, Applicatives and Monands

---

### Tuples

* Finite list (sequence) of elements so that they can be passed around as a whole
* Heterogeneous - hold different types

```tut:book
val pair = ('name, 'id)
pair.swap

val tuples = (1, "Hello World!", true, 'aSymbol)
tuples._1
tuples._4.name
tuples.productIterator.foreach(print)
```

---

### Collections - List

* Finite list (sequence) of elements so that they can be passed around as a whole
* Homogeneous - hold different types
* Construct a list
* Take the length of a list
* Reverse a list

```tut:book
val bc = 'b :: 'c :: Nil
val defg = List('d, 'e, 'f, 'g)
val abcdefgh = 'a :: bc ::: (defg :+ 'h)

abcdefgh.length
abcdefgh.reverse
```

---

### Collections - List

* Accessing the end of a list:

```tut:book
abcdefgh.head
abcdefgh.headOption
List().headOption
abcdefgh.tail
abcdefgh.init
abcdefgh.last
abcdefgh.lastOption
```

---

### Collections - List

* Prefixes and suffixes:

```tut:book
val numbers = scala.util.Random.shuffle((1 to 10).toList)

numbers.sorted

numbers.drop(3)

numbers.dropRight(2)

numbers.take(2)

numbers.takeRight(1)
```

---

### Collections - List

* Prefixes and suffixes:

```tut:book
val numbers = scala.util.Random.shuffle((1 to 10).toList)

numbers.splitAt(5)

(numbers.take(5), numbers.drop(5))
```

---

### Collections - List

* Element selection:

```tut:book
abcdefgh.apply(2)

abcdefgh(2)

abcdefgh.drop(2).head

abcdefgh.indices
```

---

### Collections - List

* List creation
* Flattening a list of lists

```tut:book
val numbers = (1 to 10 by 2).toList

val letters = ('a' to 'z' by 3).toList

letters.foreach(print); println

val listOf5 = List(List(1,2), List(3), List(), List(4, 5)).flatten
```
---

### Collections - List

* Zippings lists

```tut:book

letters.zipWithIndex

letters.indices.zip(letters)

val zipped = letters.zip(numbers)

zipped.unzip
```

---

### Collections - List

* Displaying lists

```tut:book
numbers.toString

numbers.mkString("<", ",", ">")

```

---

### Collections - List

* Higher-order methods to map over lists:

```tut:book
val numbers = (1 to 10 by 2).toList

val fps = List('fsharp, 'scala, 'haskell, 'scheme, 'clojure, 'elixir)

val fpList = fps.map(_.name.toList)

fpList.flatten

fps.flatMap(_.name.toList)
```

---

### Collections - List

* Filter lists:

```tut:book
numbers.filter(_ % 3 == 0)

fps.filter(_.name.contains('l'))

numbers.partition(_ % 3 == 0)

(numbers.filter(_ % 3 == 0), numbers.filter(_ % 3 != 0))

fps.partition(!_.name.contains('l'))

(fps.filter(!_.name.contains('l')), fps.filter(_.name.contains('l')))
```

---

### Collections - List

* Filter lists:

```tut:book
val numbers = (1 to 10 by 2).toList

val fps = List('fsharp, 'scala, 'haskell, 'scheme, 'clojure, 'elixir)

numbers.takeWhile(_ < 4)

fps.takeWhile(_.name.contains('l'))

numbers.dropWhile(_ < 4)

fps.dropWhile(_.name.contains('s'))
```

---

### Collections - List

* Filter lists:

```tut:book
val numbers = (1 to 10 by 2).toList

val fps = List('fsharp, 'scala, 'haskell, 'scheme, 'clojure, 'elixir)

numbers.span(_ < 4)
(numbers.takeWhile(_ < 4), numbers.dropWhile(_ < 4))

fps.span(_.name.contains('l'))
(fps.takeWhile(_.name.contains('l')), fps.dropWhile(_.name.contains('l')))
```

---

### Collections - List

* Predicates over lists:

```tut:book
val numbers = (1 to 10 by 2).toList

val numbersLists = List(numbers, List.fill(5)(0))

numbersLists.exists(_.forall(_ == 0))
```

---

### Collections - List

* Folding lists:

```tut:book
val numbers = (1 to 10 by 2).toList

numbers.fold(0)(_ + _)

numbers.sum

numbers.foldLeft(0)(_ + _)

numbers./:(0)(_ + _)

numbers.foldRight(0)(_ + _)

numbers.:\(0)(_ + _)
```

---

### Collections - List

* Create a range:

```tut:book
List.range(1, 5)
List.range(1, 9, 3)
List.range(9, 1, -3)
```

---

### Collections - List

* Create uniform lists:

```tut:book
List.fill(1)(1)
List.fill(1,2)(1)
List.fill(1,2,3)(1)
List.fill(1,2,3,4)(1)
List.fill(1,2,3,4,5)(1)
```

---

### Collections - List

* Create uniform lists:

```tut:book
List.tabulate(5)(x => x + x)
List.tabulate(5,3)(_ + _)
```

* Processing multiple lists

```tut:book
(List(10, 20), List(3,4,5)).zipped.map(_ + _)
```

---

### Collections - Set

```tut:book
val ranks = (2 to 10).map(x => Symbol(x.toString)).toSet + 'ace + 'king + 'jack + 'queen

var fruits = Set('apple, 'banana)
fruits += 'pear
fruits

import scala.collection.mutable
val snacks = mutable.Set('chips, 'chocolate)
snacks += 'popcorn
snacks

```

---

### Collections - Map

```tut:book
val numbers = Map(1 -> 'one, 2 -> 'two, 3 -> 'three)

numbers(3)

numbers(4)

numbers.getOrElse(4, 'four)

import scala.collection.mutable

val months = mutable.Map[Int, Symbol](1 -> 'Jan, 2 -> 'Feb, 3 -> 'Mar)

months += (4 -> 'April)
```

---

### More Collections

- Checkout https://docs.scala-lang.org/overviews/collections/introduction.html

---

### Functional Programming (FP)

* Construct all our programs using only pure functions that has no side effects including perform I/O, handle errors, modify data
* FP is restriction on how we write programs but not on what programs we can express
* Referential transparency and substitution model
* Referential transparency is in any program, the expression can be replaced by its result
without changing the meaning of the program.
* An expression e is referentially transparent if, for all program p, all occurrences of e in p
can be replaced by the result of evaluating e without affecting the meaning of p

---

### Traits & Linearization

* Fundamental unit of code reuse in Scala
* Traits encapsulates field and method definitions whcih can be reused by mixing them into classes
* Traits are not class inheritance, classes extends from traits can only inherit from one superclass
* Linearization is a deterministic process that puts all traits in a linear inheritance hierarchy

---

### Demo

---

### Modelling Data with Traits

* We express any data model in Scala in terms of logical ors and ands, like in OOP is-a and has-a relationship.
* Logical ors and ands in Functional Programming (FP) are sum and product types and together form Algebraic Data Types (ADT).

---

### Product Type (has-a and)

* If A has a b (with type B) and a c (with type C), we write

```tut:silent
case class A(b: B, c: C)
```

or

```tut:silent
trait A {
  def b: B
  def c: C
}
```

---

### Sum Type (is-a or)

* If A is a B or C, we write

```tut:silent
sealed trait A
final case class B() extends A
final case class C() extends A
```

---

### Algebraic Data Type

* A composite type, i.e., a type formed by combining other types
* Two common classes of algebraic types are
  * product types (i.e., tuples and records)
  * sum types, also called tagged or disjoint unions or variant types
* Code follows immediately from structure of the data

---

### Missing Pattern?

|          |      And      |    Or    |
|----------|:-------------:|:--------:|
| Is-a     |               | Sum Type |
| Has-a    |  Product Type |          |

* The “is-a and” pattern means that A is a B and C.
  * This pattern is in some ways the inverse of the sum type pattern, and we can implement it as below.
  * We use it to share implementation across several classes

```tut:silent
trait B
trait C
trait A extends B with C
```

---

### Missing Pattern?

|          |      And      |    Or    |
|----------|:-------------:|:--------:|
| Is-a     |               | Sum Type |
| Has-a    |  Product Type |          |

* The “has-a or” patterns means that A has a B or C
  * We can say that A has a d of type D, where D is a B or C

```tut:silent
trait A {
  def d: D
}
sealed trait D
final case class B() extends D
final case class C() extends D
```

* We can also implement "has-a or" as A is a D or E, and D has a B and E has a C.

```tut:silent
sealed trait A
final case class D(b: B) extends A
final case class E(c: C) extends A
```

---

### Examples

* A website visitor is:
  * logged in user; or
  * anonymous
* A logged in user has:
  * an ID; and
  * an email address
* An anonymous has:
  * an ID

---

### Examples

```tut:silent
sealed trait Visitor {
    id: Id
}
final case class Anonymous(id: Id)  extends Visitor
final case class User(id: Id, email: Email)  extends Visitor
```

---

### Examples

* A calculation is a success or failure
* A success has an value.
* A failure has an error message.

---

### Examples

```tut:silent
sealed trait Calculation
final case class Success(value: Int) extends Calculation
final case class Failure(msg: String) extends Calculation
```

---

### Type Class Pattern

* A type class is a trait with at least one type variable.
* The type variables specify the concrete types the type class instances are defined for.
* Methods in the trait usually use the type variables.

```tut:silent
trait ExampleTypeClass[A] {
  def doSomething(in: A): Foo
}
```

---

### Functors, Applicatives, and Monads

* http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html

---

### Recap

* Collections
* Traits - Modeling data
* Functors, Applicative and Monands

---

### References

* Programming in Scala
* Essential Scala
* Scala Design Patterns

---

### Thank you

* Q&A/Comments/Suggestions?

    </textarea>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>
    var slideshow = remark.create({
        ratio: '16:9',
        slideNumberFormat: '',
        highlightStyle: 'monokai',
        navigation: {
            scroll: false
        }
    });
</script>
</body>
</html>
