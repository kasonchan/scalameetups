# IO and Graphs with Akka Streams

---

This presentation slides are built with REPLesent!

REPLesent is a neat little tool to build presentations
using the Scala REPL.

---

## Agenda

- [better-files](https://github.com/pathikrit/better-files)
- [uPickle](http://www.lihaoyi.com/upickle/)
- [Java KeyPairGenerator](https://docs.oracle.com/javase/7/docs/api/java/security/KeyPairGenerator.html)
- [jwt-scala](https://github.com/pauldijou/jwt-scala)
- Akka Streams
  - Basic Components and operations
  - File IO
  - Streaming IO

---

## [better-files](https://github.com/pathikrit/better-files)

- Simple, safe and intuitive Scala I/O
- better-files is a dependency-free pragmatic thin Scala wrapper around [Java NIO](https://docs.oracle.com/javase/tutorial/essential/io/fileio.html).

```
libraryDependencies ++= Seq(
  "com.github.pathikrit" %% "better-files" % "3.4.0"
)
```

---

## [better-files](https://github.com/pathikrit/better-files)

```
(root/"tmp"/"diary.txt")
 .createIfNotExists()
 .appendLine()
 .appendLines("My name is", "Inigo Montoya")
 .moveToDirectory(home/"Documents")
 .renameTo("princess_diary.txt")
 .changeExtensionTo(".md")
 .lines
```

---

## Akka Streams

```
+------+   +-------+  +----+
|Source|-->|Flow(s)|->|Sink|
+------+   +-------+  +----+
```

- `Source`: Entry point of stream and must be at least one in every stream
- `Flow`: Component responsible for manipulating elements of stream and there can
  be none of any number
- `Sink`: Exit point of stream and must be at least one in every stream

---

## Akka Streams File IO Demo

---

## Akka Streams IO

```
Incoming         +----------+             +----------+
TCP/UDP Packets->|Incoming  |-ByteString->|Connection|
                 |Connection|             |Flow      |
       Outgoing<-|Flow      |<-ByteString-|          |
TCP/UDP Packets  +----------+             +----------+
```

---

## Akka Streams IO Demo

---

## [uPickle](http://www.lihaoyi.com/upickle/)

- uPickle (pronounced micro-pickle) is a lightweight serialization library for Scala

```
libraryDependencies += "com.lihaoyi" %% "upickle" % "0.5.1"
```

---

## [uPickle](http://www.lihaoyi.com/upickle/)

- Read `JSON` string and map to Scala case class

```
case class Packet(status: String, msg: String)

object Packet {
  implicit def rw: RW[Packet] = macroRW
}
```

```
...
read[Packet](e.utf8String)
...
```

---

## [uPickle](http://www.lihaoyi.com/upickle/)

- Write Scala `case class` to `JSON` string

```
case class Packet(status: String, msg: String)

object Packet {
  implicit def rw: RW[Packet] = macroRW
}
```

```
...
write(Packet("encoded", encodedMsg))
...
```

---

## [Java KeyPairGenerator](https://docs.oracle.com/javase/7/docs/api/java/security/KeyPairGenerator.html)

- Use Java `KeyPairGenerator` to generate a pair of public and private key

```
import java.security.{KeyPair, KeyPairGenerator, PrivateKey, PublicKey}

val keyGenerator = KeyPairGenerator.getInstance("RSA")

val keyPair: KeyPair = keyGenerator.generateKeyPair
val privateKey: PrivateKey = keyPair.getPrivate
val publicKey: PublicKey = keyPair.getPublic
```
---

## [jwt-scala](https://github.com/pauldijou/jwt-scala)

- JWT support for Scala. Bonus extensions for Play, Play JSON, Json4s, Circe and uPickle

```
libraryDependencies += "com.pauldijou" %% "jwt-core" % "0.14.1"
```

---

## [jwt-scala](https://github.com/pauldijou/jwt-scala)

- Basic usages

```
scala> import pdi.jwt.{Jwt, JwtAlgorithm, JwtHeader, JwtClaim, JwtOptions}
import pdi.jwt.{Jwt, JwtAlgorithm, JwtHeader, JwtClaim, JwtOptions}

scala> val token = Jwt.encode("""{"user":1}""", "secretKey", JwtAlgorithm.HS256)
token: String = eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VyIjoxfQ.oG3iKnAvj_OKCv0tchT90sv2IFVeaREgvJmwgRcXfkI

scala> Jwt.decodeRawAll(token, "secretKey", Seq(JwtAlgorithm.HS256))
res0: scala.util.Try[(String, String, String)] = Success(({"typ":"JWT","alg":"HS256"},{"user":1},oG3iKnAvj_OKCv0tchT90sv2IFVeaREgvJmwgRcXfkI))

scala> Jwt.decodeRawAll(token, "wrongKey", Seq(JwtAlgorithm.HS256))
res1: scala.util.Try[(String, String, String)] = Failure(pdi.jwt.exceptions.JwtValidationException: Invalid signature for this token or wrong algorithm.)
```

---

## [jwt-scala](https://github.com/pauldijou/jwt-scala)

- Encode message with algorithm `RS512` using the private key that is generated by Java KeyPairGenerator

```
...
val encodedMsg = Jwt.encode(j.msg, privateKey, JwtAlgorithm.RS512)
...
```

---

## [jwt-scala](https://github.com/pauldijou/jwt-scala)

- Decode message with algorithm `RS512` using the public key that is generated by Java KeyPairGenerator
- A 3-tuple packet `decodedPacket` will be created after decryption, second
  element is the decoded message that we want to return back to the user

```
...
val decodedPacket: Try[(String, String, String)] =
  Jwt.decodeRawAll(j.msg, publicKey, Seq(JwtAlgorithm.RS512))
  system.log.info(s"Decoded $decodedPacket")
  decodedPacket match {
    case Success(d) =>
      system.log.info(
        s"Sent ${write(Packet("decoded", d._2)).toString}")
      write(Packet("decoded", d._2))
    case Failure(_) =>
      system.log.warning(
        s"Invalid json format, missing element? ${e.utf8String}")
      system.log.warning(
        s"Sent ${write(Packet("meh", "Invalid status")).toString}")
      write(
        Packet("meh", "Invalid json format, missing element?"))
  }
...
```

---

## Akka Streams IO

- Run the following command to encode a message

```
echo -n '{"$type":"messages.Packet","status":"encode","msg":"Hello world from Akka Stream"}' | nc 127.0.0.1 19999
```

- Run the following command to decode a message, replace your `<ecodedMsg>` with the encoded message from the last command

```
echo -n '{"$type":"messages.Packet","status":"decode","msg":"<encodedMsg>"}' | nc 127.0.0.1 19999
```

---

## Akka Streams IO

- `Flow` process `ByteString` s from and to the TCP Socket
- `Framing.delimiter` helper `Flow` to chunk the inputs up into actual lines of text
  - 1 `ByteString` does not have to correspond to exactly one line of text
- `allowTruncation` boolean argument indicates we require an explicit line ending even for the last message before the connection is closed

---

## References

- [better-files](https://github.com/pathikrit/better-files)
- [uPickle](http://www.lihaoyi.com/upickle/)
- [Java KeyPairGenerator](https://docs.oracle.com/javase/7/docs/api/java/security/KeyPairGenerator.html)
- [jwt-scala](https://github.com/pauldijou/jwt-scala)
- Akka Streams
  - https://doc.akka.io/docs/akka/2.5/stream/stream-quickstart.html
  - Akka Cookbook

---

## Thank you for coming!

## Q&A/Comments/Suggestions?

---

This presentation is built with [REPLesent](https://github.com/marconilanna/REPLesent).

To run the slides, first create the follow alias:

```
alias REPLesent='scala -Dscala.color -language:_ -nowarn -i REPLesent.scala'
```

Open the REPL and enter the statements below to start the presentation:

```
$ REPLesent
Welcome to Scala 2.12.3 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_65).
Type in expressions for evaluation. Or try :help.

scala> val replesent = REPLesent(intp=$intp,source="~/Documents/workspace/scalameetups/scalameetup19/README.md")
replesent: REPLesent = REPLesent(0,0,~/Documents/workspace/scalameetups/scalameetup19/README.md,true,true,scala.tools.nsc.interpreter.ILoop$ILoopInterpreter@3b80bb63)

scala> import replesent._
import replesent._

scala> f
```
